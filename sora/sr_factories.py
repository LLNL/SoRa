from deap import tools
from deap import gp
from deap import algorithms
import json
from optparse import OptionParser
import sr_mutators
import random

defaultConfigData = { "infile"            : "foo",
                "infileExtension"   : "dat",
                "filters"           : [],
                "inVars"   : [ "x" ],
                "targetVar" : "target",
                "seed"   : 0,
                "depthLimit" : 17,
                "prettyPrint" : True,
                "logFilename" : None,
                "select" : [ { "type" : "SPEA2" } ],
                "algo"   : {
                          "type" : "eaMuCommaLambda",
                          "initialPopulationSize" : 400,
                          "stopFrequency"  : 100,
                          "numGenerations" : 400,
                          "populationSize" : 400,
                          "children" : 600,
                          "cxpb"     : 0.7,
                          "mutpb"    : 0.2
                          },
                "mate"     : "cxOnePoint",
                "mutator"  : { "type" : "mutUniform" },
                "primitives" : ["add", "sub", "mul", "div", "neg", "sqrt"],
                "errorfunc": "avgAbsErrorSquared"
                }

#All the expression generators take the same inputs, min, max, and pset.  So it's easy to set up defaults    
genExprDefaults = { "type"  : "genFull",
                    "min_"  : 0,
                    "max_"  : 4
                  }


eaMuPlusLambdaDefaults = { "type"  : "eaMuPlusLambda",
                           "initialPopulationSize" : 400,
                           "stopFrequency"  : 100,
                           "numGenerations" : 400,
                           "populationSize" : 400,
                           "children" : 400,
                           "cxpb"     : 0.7,
                           "mutpb"    : 0.2
                           }

eaMuCommaLambdaDefaults = { "type"  : "eaMuCommaLambda",
                           "initialPopulationSize" : 400,
                           "stopFrequency"  : 100,
                           "numGenerations" : 400,
                           "populationSize" : 400,
                           "children" : 600,
                           "cxpb"     : 0.7,
                           "mutpb"    : 0.2
                           }

eaHARMDefaults = { "type"  : "harm",
                   "initialPopulationSize" : 400,
                   "numGenerations" : 400,
                   "stopFrequency"  : 100,
                   "cxpb"     : 0.7,
                   "mutpb"    : 0.2,
                   "alpha"    : 0.05,
                   "beta"     : 10,
                   "gamma"    : 0.25,
                   "rho"      : 0.9,
                   "nbrindsmodel" : -1,
                   "mincutoff" : 20
                  }

islandsDefaults = { "migrationFreq" : 50,
                    "numMigrants" : 10,
                    "select"            : [ { "type" : "SPEA2" } ],
                    "replacementSelect" : [ { "type" : None } ]
                  }
#filename base means no checkpoint will be generated by default
#allRanks = False only outputs a checkpoint file for rank 0.  (True will output a file for each rank) 
checkpointsDefaults = {
    "filenamebase" : None,
    "allRanks"     : False,
    "frequency"    : 100
    }


def add_options(op):
    """
    """
    assert(isinstance(op, OptionParser))

    # Paging
    op.add_option("-i", "--input-file", 
                  action="store", dest="inputFile", type="string",  default=None,
                  help="The name of the input file")
    op.add_option("-t", "--num-threads", 
                  action="store", dest="numThreads", type="int", default=1,
                  help="The number of threads (actually processes) to use for evaluation")
    op.add_option("-p", "--print-level", 
                  action="store", dest="printLevel", type="int", default=2,
                  help="Print level defines the verbosity of the output.  Lower numbers give less output.\n 0: Errors and hall of fame only\n 1: Warning and Errors\n 2: Errors, Warnings, and generational statistics 5: All debugging output")
    op.add_option("-r", "--all-ranks-print", 
                  action="store_true", dest="allRanksPrint", default=False,
                  help="All Ranks Print describes how the printlevel is applied on different ranks.  By default only rank 0 outputs anything.")
    op.add_option("-c", "--load-checkpoint", 
                  action="store", dest="loadCheckpoint", default=None,
                  help="To restart a run pass the checkpoint file basename to load.  The Resulting filename will be \"<name>.<rank>.check\".  For example \"TF.0.check\".  All ranks that find a checkpoint file will load it, otherwise they will generate a new population.")
    


#Selection factory returns a selection function (such as SPEA2 or tournament)
#However, it can loop through different selection algorithms so different islands
#can use different selection.  So:
#Selection factory takes a LIST of names, and a rank.
#The rank is the ID of the population
#
# Currently only 2 are availible.  sortNonDominated may also be an option, but I'm not sure
def selectionFactory(sectionName, rank, config, toolbox):
    selectionArray = config[sectionName]
    selectionId = rank % len(selectionArray)
    selectBlock = selectionArray[selectionId]
    name = selectBlock["type"]

    if(name == None):
        pass
    elif(name.lower() == "spea2"):
        toolbox.register(sectionName, tools.selSPEA2)
    elif(name.lower() == "nsga2"):
        toolbox.register(sectionName, tools.selNSGA2)
    elif(name.lower() == "selbest"):  #The below are not suitable for multi-objective optimization
        toolbox.register(sectionName, tools.selBest)
    elif(name.lower() == "selworst"): #Should work OK as replacement
        toolbox.register(sectionName, tools.selWorst)
    elif(name.lower() == "selrandom"): 
        toolbox.register(sectionName, tools.selRandom)
    elif(name.lower() == "seltournament"):
        kwargs = setDefaults(selectBlock, { "tournsize" : 4 })
        kwargs.__delitem__("type")
        toolbox.register(sectionName, tools.selTournament, **kwargs)  
    elif(name.lower() == "selroulette"):
        toolbox.register(sectionName, tools.selRoulette)
    elif(name.lower() == "seldoubletournament"):
        kwargs = setDefaults(selectBlock, { "fitness_size" : 4, "parsimony_size" : 1.4, "fitness_first" : False})
        kwargs.__delitem__("type")
        toolbox.register(sectionName, tools.selDoubleTournament, **kwargs)
        

#Mutation factory registers all mutation function in the config file (such as mutUniform)
# A configuration block, of the form { "type" : "mutEphemeral", "mode" : "all" }
# A toolbox: The global tool box
# pset: 
def mutationFactory(mut_config, toolbox, pset):

    if(mut_config["type"] == "multiMutOr"):
        return(sr_mutators.multiMutOr(mut_config, toolbox, pset), {})
        
    elif(mut_config["type"] == "mutUniform"):
        kwargs = {}   #No real arguments to mutUniform
        kwargs["expr"] = toolbox.expr_mut;
        kwargs["pset"] = pset
        return(gp.mutUniform, kwargs)
        
    elif(mut_config["type"] == "mutNodeReplacement"):
        kwargs = {}   #No real arguments to mutUniform
        kwargs["pset"] = pset
        return(gp.mutNodeReplacement, kwargs)
    elif(mut_config["type"] == "mutShrink"):
        return(gp.mutShrink, {})
    elif(mut_config["type"] == "mutEphemeral"):
        kwargs = {}
        if(mut_config.has_key("mode")):
            kwargs["mode"] = mut_config["mode"]
        else:
            kwargs["mode"] = "all"  #"one" is the other choice
        return(gp.mutEphemeral, kwargs)
    elif(mut_config["type"] == "mutInsert"):
        kwargs = {}   #No real arguments to mutInsert
        kwargs["pset"] = pset
        return(gp.mutInsert, kwargs)

    else:
        raise ValueException("mutationFactory: Unknown mutator type %s", mut_config["type"])



# registorMutator is just a helper function that calls mutationFactory to create
# the mutator, then immediately registers it.
def registerMutator(config, toolbox, pset):
    mut_block = {}
    if(config.has_key("mutator")):
        mut_block = config["mutator"]

    mut_block = setDefaults(mut_block, { "type" : "mutUniform" })

    (mutator, kwargs) = mutationFactory(mut_block, toolbox, pset)
    toolbox.register("mutate", mutator, **kwargs)


#There are at least two ways to generate an possible function (or subfunction)
#expr does the starting trees, expr_mut does the subtrees that get adding in mutation
# exprFactory handles both cases, and will produce a default if the configuration file
# doesn't specify anything
def exprFactory(expr_block_name, config, toolbox, pset):
    expr_block = {}
    if(config.has_key(expr_block_name)):
        expr_block = config[expr_block_name]

    expr_block = setDefaults(expr_block, genExprDefaults)

    if(expr_block["type"] == "genFull"):
       expr_block.__delitem__("type")
       expr_block["pset"] = pset
       toolbox.register(expr_block_name, gp.genFull, **expr_block)       
    elif(expr_block["type"] == "genGrow"):
       expr_block.__delitem__("type")
       expr_block["pset"] = pset
       toolbox.register(expr_block_name, gp.genGrow, **expr_block)       
    elif(expr_block["type"] == "genHalfAndHalf"):
       expr_block.__delitem__("type")
       expr_block["pset"] = pset
       toolbox.register(expr_block_name, gp.genHalfAndHalf, **expr_block)       

# HallOfFame determines if we're doing single or multiobjective runs.
# A ParetoFront HoF is multiobjective, a HallOfFame is single objective
def hofFactory(config):
    hofblock = config["HallOfFame"]
    typestr = hofblock["type"]

    if(typestr.lower() == "pareto"):
        return tools.ParetoFront()
    else:
        kwargs = setDefaults(hofblock, { "size" : 10 })
        return tools.HallOfFame(kwargs["size"])

def registerAlgorithm(algo_config, toolbox, stats, halloffame, verbose):
    """registerAlgorithm is a simple factory / registering function for evolutionary algorithms.
    It figures out the algorithm to register from the configuration file and sets it up with a
    combonation of defaults and what's in the configuration.
    It returns the algorithm configuration in case there was anything new from the defaults.

    Currently HARM, eaMuPlusLambda, and eaMuCommaLambda are availible algorithms

    :param algo_config: The algorithm configuration dictionary.  e.g. eaHARMDefaults
    :param toolbox: The toolbox to register in
    :param stats:   The MultiStatistics object, gets registered in the algorithm
    :param halloffame: The Hall of Fame object gets registered in the algorithm
    :param verbose: Boolean, true prints out stats from each generation.
    :return algoArgs: Returns the algorithm configuration dictionary because the main loop needs it
    """
    if(algo_config["type"] == "eaMuPlusLambda"):
        algoArgs = setDefaults(algo_config, eaMuPlusLambdaDefaults)

        toolbox.register("algorithm", algorithms.eaMuPlusLambda, toolbox=toolbox,
                         mu=algoArgs["populationSize"], lambda_=algoArgs["children"],
                         cxpb=algoArgs["cxpb"], mutpb=algoArgs["mutpb"],
                         ngen=algoArgs["stopFrequency"], stats=stats, halloffame=halloffame,
                         verbose=verbose)

    elif(algo_config["type"] == "eaMuCommaLambda"):
        algoArgs = setDefaults(algo_config, eaMuCommaLambdaDefaults)
        toolbox.register("algorithm", algorithms.eaMuCommaLambda, toolbox=toolbox,
                       mu=algoArgs["populationSize"], lambda_=algoArgs["children"],
                       cxpb=algoArgs["cxpb"], mutpb=algoArgs["mutpb"],
                       ngen=algoArgs["stopFrequency"], stats=stats, halloffame=halloffame,
                       verbose=verbose)

    elif(algo_config["type"] == "harm"):
        algoArgs = setDefaults(algo_config, eaHARMDefaults)
        toolbox.register("algorithm", gp.harm, toolbox=toolbox,
                         cxpb=algoArgs["cxpb"], mutpb=algoArgs["mutpb"],
                         alpha=algoArgs["alpha"], beta=algoArgs["beta"], gamma=algoArgs["gamma"], rho=algoArgs["rho"],
                         ngen=algoArgs["stopFrequency"], nbrindsmodel=algoArgs["nbrindsmodel"],
                         mincutoff=algoArgs["mincutoff"],
                         stats=stats, halloffame=halloffame,
                         verbose=verbose)
    else:
        raise ValueError("Unknown evolution algorithm %s" % algo_config["type"])
    return algoArgs

def constantFactory(constants, pset):

    for const_block in constants:
        if(not const_block.has_key("type")):
            raise ValueError("Constant block in configuration missing type key.\n %s" % str(const_block));
        typename = const_block["type"].lower()

        if typename == "randint":
            if(not const_block.has_key("min") or not const_block.has_key("max")):
                raise ValueError("Constant randint in configuration must have min and max values.\n %s" % str(const_block));
            minn = int(const_block["min"])
            maxx = int(const_block["max"])
            pset.addEphemeralConstant("randint%d.%d" %(minn, maxx), lambda: random.randint(minn,maxx))
        elif typename == "uniform":
            if(not const_block.has_key("min") or not const_block.has_key("max")):
                raise ValueError("Constant uniform in configuration must have min and max values.\n %s" % str(const_block));
            minn = int(const_block["min"])
            maxx = int(const_block["max"])
            pset.addEphemeralConstant("uniform%d.%d" %(minn, maxx), lambda: random.uniform(minn,maxx))
        elif typename == "normal":
            if(not const_block.has_key("mu") or not const_block.has_key("sigma")):
                raise ValueError("Constant normal in configuration must have mu and sigma values.\n %s" % str(const_block));
            mu = int(const_block["mu"])
            sigma = int(const_block["sigma"])
            pset.addEphemeralConstant("normal%d.%d" %(mu, sigma), lambda: random.normalvariate(mu,sigma))
        elif typename == "gamma":
            if(not const_block.has_key("alpha") or not const_block.has_key("beta")):
                raise ValueError("Constant gamma in configuration must have alpha and beta values.\n %s" % str(const_block));
            alpha = int(const_block["alpha"])
            beta = int(const_block["beta"])
            pset.addEphemeralConstant("normal%d.%d" %(alpha, beta), lambda: random.gammavariate(alpha,beta))
        elif typename == "constant":
            if(not const_block.has_key("value")):
                raise ValueError("Constant constant in configuration must have value.\n %s" % str(const_block));
            value = int(const_block["value"])
            pset.addEphemeralConstant("const%d" %(value), lambda: value)
        else:
            raise ValueError("Unknown constant type %s\n" % typename)


def setDefaults(indict, defaults):

    thisData = defaults.copy()
    thisData.update(indict)
    return thisData
